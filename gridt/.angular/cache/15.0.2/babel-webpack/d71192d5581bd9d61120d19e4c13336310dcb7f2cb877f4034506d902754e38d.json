{"ast":null,"code":"import { of, pipe, throwError, forkJoin } from 'rxjs';\nimport { SecureStorageService } from './secure-storage.service';\nimport { flatMap, tap, catchError, map, mapTo, pluck } from 'rxjs/operators';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./secure-storage.service\";\nvar AuthService = /** @class */function () {\n  function AuthService(http, secStore) {\n    var _this = this;\n    this.http = http;\n    this.secStore = secStore;\n    this.error_codes = {\n      TOKENEXPIRED: \"Token expired\",\n      TOKENUNAVAILABLE: 'Key \"token\" does not exist in the secure storage.',\n      NOCREDENTIALS: \"Can't authenticate: no credentials\",\n      INVALIDCREDENTIALS: \"Authentication unsuccessful: invalid credentials\"\n    };\n    /**\n     * Observable to obtain credentials from the secure storage.\n     */\n    this.getCredentials = forkJoin({\n      username: this.secStore.get$(\"email\"),\n      password: this.secStore.get$(\"password\")\n    });\n    /**\n     * Pipe to make an AccessToken object into headers that can be used for API calls.\n     */\n    this.prepareOptions = pipe(map(function (accesToken) {\n      return {\n        headers: new HttpHeaders({\n          Authorization: \"JWT \".concat(accesToken.access_token)\n        })\n      };\n    }));\n    /**\n     * One-shot observable to ready authentication for API calls.\n     *\n     * This observable follows the flow diagram in the documentation.\n     */\n    this.readyAuthentication$ = this.secStore.get$(\"token\").pipe(map(function (token_string) {\n      return {\n        access_token: token_string\n      };\n    }), flatMap(function (token) {\n      if (_this.isTokenExpired(token)) {\n        return throwError(_this.error_codes.TOKENEXPIRED);\n      } else {\n        return of(token);\n      }\n    }), catchError(function (error) {\n      if (error == _this.error_codes.TOKENEXPIRED || error == _this.error_codes.TOKENUNAVAILABLE) {\n        return _this.getCredentials.pipe(catchError(function () {\n          return throwError(_this.error_codes.NOCREDENTIALS);\n        }), _this.authenticate(),\n        // Bind neccessary to keep \"this\" pointing to service (instead of tap)\n        tap(_this.storeToken.bind(_this)));\n      } else {\n        return throwError(error);\n      }\n    }), this.prepareOptions);\n    /**\n     * Checks if a sucessful login has happened by searching for a token in\n     * the secure storage.\n     */\n    this.isLoggedIn$ = this.secStore.get$(\"token\").pipe(map(function () {\n      return true;\n    }), catchError(function () {\n      return of(false);\n    }));\n  }\n  /**\n   * Check if the experiation date in the JWT token is expired.\n   * @param token Token to be evaluated\n   */\n  AuthService.prototype.isTokenExpired = function (accessToken) {\n    var token = accessToken.access_token;\n    var exp = JSON.parse(atob(token.split(\".\")[1]))[\"exp\"];\n    var expiration_date = new Date(exp * 1000);\n    if (expiration_date < new Date()) {\n      console.debug(\"Token expired. Expiration date: \".concat(expiration_date));\n      return true;\n    }\n    return false;\n  };\n  /**\n   * Pipe to handle authentication. Clears credentials when fails to authenticate.\n   */\n  AuthService.prototype.authenticate = function () {\n    var _this = this;\n    return pipe(tap(function () {\n      return console.debug(\"Performing authentiation API call.\");\n    }), flatMap(function (credentials) {\n      return _this.http.post('https://api.gridt.org/auth', credentials // TODO: Get rid of hardcoded URL\n      );\n    }), catchError(function (error) {\n      // JWT error\n      if (error.status == 401) {\n        _this.logout();\n        return throwError(_this.error_codes.INVALIDCREDENTIALS);\n      }\n      // Error in server response\n      if (error.status) {\n        return throwError(error.message);\n      }\n      // Error in previous steps\n      return throwError(error);\n    }));\n  };\n  /**\n   * Store credentials in the secure storage.\n   * @param credentials Credentials to be stored.\n   */\n  AuthService.prototype.storeCredentials = function (credentials) {\n    this.secStore.set$(\"email\", credentials.username).subscribe();\n    this.secStore.set$(\"password\", credentials.password).subscribe();\n  };\n  /**\n   * Store token in secure storage.\n   * @param token Token to be stored\n   */\n  AuthService.prototype.storeToken = function (token) {\n    this.secStore.set$(\"token\", token.access_token).subscribe();\n  };\n  /**\n   * Log the user in on the server, obtaining a token.\n   * @param email Email used for logging.\n   * @param password Password for identification.\n   * @returns Observable that will true if the login was succesful and be false if unsuccesful.\n   */\n  AuthService.prototype.login$ = function (email, password) {\n    var _this = this;\n    var credentials = {\n      username: email,\n      password: password\n    };\n    return of(credentials).pipe(tap(function (c) {\n      return _this.storeCredentials(c);\n    }), this.authenticate(), tap(this.storeToken.bind(this)), mapTo(true), catchError(function () {\n      _this.secStore.clear$().subscribe();\n      return of(false); // Not sure if this is better, or just leave the error.\n    }));\n  };\n  /**\n   * Register the user on the server.\n   * @param username Username to identify user\n   * @param email Email to reach user\n   * @param password Password to identify user.\n   */\n  AuthService.prototype.register$ = function (username, email, password) {\n    console.debug(\"Registering user \".concat(username, \".\"));\n    return this.http.post(\"https://api.gridt.org/register\", {\n      username: username,\n      email: email,\n      password: password\n    }).pipe(pluck(\"message\"), catchError(function (error) {\n      return throwError(error.error.message);\n    }));\n  };\n  /**\n   * Clear all information stored in the secure storage concerning previous logins.\n   */\n  AuthService.prototype.logout = function () {\n    this.secStore.clear$().subscribe();\n  };\n  AuthService.ɵfac = function AuthService_Factory(t) {\n    return new (t || AuthService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.SecureStorageService));\n  };\n  AuthService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthService,\n    factory: AuthService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthService;\n}();\nexport { AuthService };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}